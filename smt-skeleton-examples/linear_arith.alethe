unsat
(assume a0 (and (>= x (* 3 y)) (<= x y) (< (- 2) x)))
(assume a1 (not (<= (- y x) (/ 2 3))))
(step t1 (cl (not (= (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) (or (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))))) (not (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1))))) (or (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1))))) :rule equiv_pos2)
(step t2 (cl (= (= (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3))) true) (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) :rule equiv_simplify)
(step t3 (cl (not (= (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3))) true)) (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule equiv1 :premises (t2))
(step t4 (cl (= (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (= (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))))) :rule all_simplify)
(step t5 (cl (= (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule refl)
(step t6 (cl (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule all_simplify)
(step t7 (cl (= (= (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) (= (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) :rule cong :premises (t5 t6))
(step t8 (cl (= (= (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (>= (+ (* (- 1) y) x) (/ (- 2) 3))) true)) :rule all_simplify)
(step t9 (cl (= (= (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) true)) :rule trans :premises (t7 t8))
(step t10 (cl (= (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3))) true)) :rule trans :premises (t4 t9))
(step t11 (cl (= (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule resolution :premises (t3 t10))
(step t12 (cl (= (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)))) :rule refl)
(step t13 (cl (= (not (>= x (- 1))) (not (>= x (- 1))))) :rule refl)
(step t14 (cl (= (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) (or (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))))) :rule cong :premises (t11 t12 t13))
(step t15 (cl (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false) (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) :rule implies_neg1)
(anchor :step t16)
(assume t16.a0 (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))
(assume t16.a1 (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0))
(assume t16.a2 (>= x (- 1)))
(step t16.t1 (cl (not (= (< x (- 1)) (not (>= x (- 1))))) (not (< x (- 1))) (not (>= x (- 1)))) :rule equiv_pos2)
(step t16.t2 (cl (= (< x (- 1)) (not (>= x (- 1))))) :rule all_simplify)
(step t16.t3 (cl (not (= (not (>= x (- 1))) (< x (- 1)))) (not (not (>= x (- 1)))) (< x (- 1))) :rule equiv_pos2)
(step t16.t4 (cl (= (not (>= x (- 1))) (< x (- 1)))) :rule symm :premises (t16.t2))
(step t16.t5 (cl (=> (>= x (- 1)) false) (>= x (- 1))) :rule implies_neg1)
(anchor :step t16.t6)
(assume t16.t6.a0 (>= x (- 1)))
(step t16.t6.t1 (cl (not (= (< (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3)))) false)) (not (< (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))))) false) :rule equiv_pos2)
(step t16.t6.t2 (cl (= (< (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3)))) (not (>= (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))))))) :rule all_simplify)
(step t16.t6.t3 (cl (= (* (- 1.0) x) (to_real (* (- 1) x)))) :rule all_simplify)
(step t16.t6.t4 (cl (= (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (+ (* (/ 3 2) y) (* (/ (- 1) 2) x)))) :rule all_simplify)
(step t16.t6.t5 (cl (= (* (/ (- 3) 2) (+ y (* (- 1) x))) (+ (* (/ (- 3) 2) y) (* (/ 3 2) x)))) :rule all_simplify)
(step t16.t6.t6 (cl (= (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (to_real (* (- 1) x)) (+ (* (/ 3 2) y) (* (/ (- 1) 2) x)) (+ (* (/ (- 3) 2) y) (* (/ 3 2) x))))) :rule cong :premises (t16.t6.t3 t16.t6.t4 t16.t6.t5))
(step t16.t6.t7 (cl (= (+ (to_real (* (- 1) x)) (+ (* (/ 3 2) y) (* (/ (- 1) 2) x)) (+ (* (/ (- 3) 2) y) (* (/ 3 2) x))) 0.0)) :rule all_simplify)
(step t16.t6.t8 (cl (= (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) 0.0)) :rule trans :premises (t16.t6.t6 t16.t6.t7))
(step t16.t6.t9 (cl (= (* (- 1.0) (- 1)) 1.0)) :rule all_simplify)
(step t16.t6.t10 (cl (= (* (/ 3 2) 0.0) 0.0)) :rule all_simplify)
(step t16.t6.t11 (cl (= (* (/ (- 3) 2) (/ 2 3)) (- 1.0))) :rule all_simplify)
(step t16.t6.t12 (cl (= (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))) (+ 1.0 0.0 (- 1.0)))) :rule cong :premises (t16.t6.t9 t16.t6.t10 t16.t6.t11))
(step t16.t6.t13 (cl (= (+ 1.0 0.0 (- 1.0)) 0.0)) :rule all_simplify)
(step t16.t6.t14 (cl (= (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))) 0.0)) :rule trans :premises (t16.t6.t12 t16.t6.t13))
(step t16.t6.t15 (cl (= (>= (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3)))) (>= 0.0 0.0))) :rule cong :premises (t16.t6.t8 t16.t6.t14))
(step t16.t6.t16 (cl (= (>= 0.0 0.0) true)) :rule all_simplify)
(step t16.t6.t17 (cl (= (>= (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3)))) true)) :rule trans :premises (t16.t6.t15 t16.t6.t16))
(step t16.t6.t18 (cl (= (not (>= (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))))) (not true))) :rule cong :premises (t16.t6.t17))
(step t16.t6.t19 (cl (= (not true) false)) :rule all_simplify)
(step t16.t6.t20 (cl (= (not (>= (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))))) false)) :rule trans :premises (t16.t6.t18 t16.t6.t19))
(step t16.t6.t21 (cl (= (< (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3)))) false)) :rule trans :premises (t16.t6.t2 t16.t6.t20))
(step t16.t6.t22 (cl (not (<= (* (- 1.0) x) (* (- 1.0) (- 1)))) (not (<= (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ 3 2) 0.0))) (not (< (* (/ (- 3) 2) (+ y (* (- 1) x))) (* (/ (- 3) 2) (/ 2 3)))) (< (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))))) :rule la_generic :args (1 1 1 1))
(step t16.t6.t23 (cl (=> (and (< (- 1.0) 0) (>= x (- 1))) (<= (* (- 1.0) x) (* (- 1.0) (- 1))))) :rule la_mult_neg)
(step t16.t6.t24 (cl (not (and (< (- 1.0) 0) (>= x (- 1)))) (<= (* (- 1.0) x) (* (- 1.0) (- 1)))) :rule implies :premises (t16.t6.t23))
(step t16.t6.t25 (cl (and (< (- 1.0) 0) (>= x (- 1))) (not (< (- 1.0) 0)) (not (>= x (- 1)))) :rule and_neg)
(step t16.t6.t26 (cl (= (= (< (- 1.0) 0) true) (< (- 1.0) 0))) :rule equiv_simplify)
(step t16.t6.t27 (cl (not (= (< (- 1.0) 0) true)) (< (- 1.0) 0)) :rule equiv1 :premises (t16.t6.t26))
(step t16.t6.t28 (cl (= (< (- 1.0) 0) true)) :rule hole :args ((< (- 1.0) 0)))
(step t16.t6.t29 (cl (< (- 1.0) 0)) :rule resolution :premises (t16.t6.t27 t16.t6.t28))
(step t16.t6.t30 (cl (and (< (- 1.0) 0) (>= x (- 1)))) :rule resolution :premises (t16.t6.t25 t16.t6.t29 t16.t6.a0))
(step t16.t6.t31 (cl (<= (* (- 1.0) x) (* (- 1.0) (- 1)))) :rule resolution :premises (t16.t6.t24 t16.t6.t30))
(step t16.t6.t32 (cl (=> (and (> (/ 3 2) 0) (<= (+ y (* (/ (- 1) 3) x)) 0.0)) (<= (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ 3 2) 0.0)))) :rule la_mult_pos)
(step t16.t6.t33 (cl (not (and (> (/ 3 2) 0) (<= (+ y (* (/ (- 1) 3) x)) 0.0))) (<= (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ 3 2) 0.0))) :rule implies :premises (t16.t6.t32))
(step t16.t6.t34 (cl (and (> (/ 3 2) 0) (<= (+ y (* (/ (- 1) 3) x)) 0.0)) (not (> (/ 3 2) 0)) (not (<= (+ y (* (/ (- 1) 3) x)) 0.0))) :rule and_neg)
(step t16.t6.t35 (cl (= (= (> (/ 3 2) 0) true) (> (/ 3 2) 0))) :rule equiv_simplify)
(step t16.t6.t36 (cl (not (= (> (/ 3 2) 0) true)) (> (/ 3 2) 0)) :rule equiv1 :premises (t16.t6.t35))
(step t16.t6.t37 (cl (= (> (/ 3 2) 0) true)) :rule hole :args ((> (/ 3 2) 0)))
(step t16.t6.t38 (cl (> (/ 3 2) 0)) :rule resolution :premises (t16.t6.t36 t16.t6.t37))
(step t16.t6.t39 (cl (not (= (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (<= (+ y (* (/ (- 1) 3) x)) 0.0))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (<= (+ y (* (/ (- 1) 3) x)) 0.0)) :rule equiv_pos2)
(step t16.t6.t40 (cl (= (<= (+ y (* (/ (- 1) 3) x)) 0.0) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0))) :rule all_simplify)
(step t16.t6.t41 (cl (= (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (<= (+ y (* (/ (- 1) 3) x)) 0.0))) :rule symm :premises (t16.t6.t40))
(step t16.t6.t42 (cl (<= (+ y (* (/ (- 1) 3) x)) 0.0)) :rule resolution :premises (t16.t6.t39 t16.t6.t41 t16.a1))
(step t16.t6.t43 (cl (and (> (/ 3 2) 0) (<= (+ y (* (/ (- 1) 3) x)) 0.0))) :rule resolution :premises (t16.t6.t34 t16.t6.t38 t16.t6.t42))
(step t16.t6.t44 (cl (<= (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ 3 2) 0.0))) :rule resolution :premises (t16.t6.t33 t16.t6.t43))
(step t16.t6.t45 (cl (=> (and (< (/ (- 3) 2) 0) (> (+ y (* (- 1) x)) (/ 2 3))) (< (* (/ (- 3) 2) (+ y (* (- 1) x))) (* (/ (- 3) 2) (/ 2 3))))) :rule la_mult_neg)
(step t16.t6.t46 (cl (not (and (< (/ (- 3) 2) 0) (> (+ y (* (- 1) x)) (/ 2 3)))) (< (* (/ (- 3) 2) (+ y (* (- 1) x))) (* (/ (- 3) 2) (/ 2 3)))) :rule implies :premises (t16.t6.t45))
(step t16.t6.t47 (cl (and (< (/ (- 3) 2) 0) (> (+ y (* (- 1) x)) (/ 2 3))) (not (< (/ (- 3) 2) 0)) (not (> (+ y (* (- 1) x)) (/ 2 3)))) :rule and_neg)
(step t16.t6.t48 (cl (= (= (< (/ (- 3) 2) 0) true) (< (/ (- 3) 2) 0))) :rule equiv_simplify)
(step t16.t6.t49 (cl (not (= (< (/ (- 3) 2) 0) true)) (< (/ (- 3) 2) 0)) :rule equiv1 :premises (t16.t6.t48))
(step t16.t6.t50 (cl (= (< (/ (- 3) 2) 0) true)) :rule hole :args ((< (/ (- 3) 2) 0)))
(step t16.t6.t51 (cl (< (/ (- 3) 2) 0)) :rule resolution :premises (t16.t6.t49 t16.t6.t50))
(step t16.t6.t52 (cl (not (= (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (> (+ y (* (- 1) x)) (/ 2 3)))) (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (> (+ y (* (- 1) x)) (/ 2 3))) :rule equiv_pos2)
(step t16.t6.t53 (cl (= (> (+ y (* (- 1) x)) (/ 2 3)) (not (<= (+ y (* (- 1) x)) (/ 2 3))))) :rule all_simplify)
(step t16.t6.t54 (cl (= (<= (+ y (* (- 1) x)) (/ 2 3)) (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule all_simplify)
(step t16.t6.t55 (cl (= (not (<= (+ y (* (- 1) x)) (/ 2 3))) (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) :rule cong :premises (t16.t6.t54))
(step t16.t6.t56 (cl (= (> (+ y (* (- 1) x)) (/ 2 3)) (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) :rule trans :premises (t16.t6.t53 t16.t6.t55))
(step t16.t6.t57 (cl (= (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (> (+ y (* (- 1) x)) (/ 2 3)))) :rule symm :premises (t16.t6.t56))
(step t16.t6.t58 (cl (> (+ y (* (- 1) x)) (/ 2 3))) :rule resolution :premises (t16.t6.t52 t16.t6.t57 t16.a0))
(step t16.t6.t59 (cl (and (< (/ (- 3) 2) 0) (> (+ y (* (- 1) x)) (/ 2 3)))) :rule resolution :premises (t16.t6.t47 t16.t6.t51 t16.t6.t58))
(step t16.t6.t60 (cl (< (* (/ (- 3) 2) (+ y (* (- 1) x))) (* (/ (- 3) 2) (/ 2 3)))) :rule resolution :premises (t16.t6.t46 t16.t6.t59))
(step t16.t6.t61 (cl (< (+ (* (- 1.0) x) (* (/ 3 2) (+ y (* (/ (- 1) 3) x))) (* (/ (- 3) 2) (+ y (* (- 1) x)))) (+ (* (- 1.0) (- 1)) (* (/ 3 2) 0.0) (* (/ (- 3) 2) (/ 2 3))))) :rule resolution :premises (t16.t6.t22 t16.t6.t31 t16.t6.t44 t16.t6.t60))
(step t16.t6.t62 (cl false) :rule resolution :premises (t16.t6.t1 t16.t6.t21 t16.t6.t61))
(step t16.t6 (cl (not (>= x (- 1))) false) :rule subproof :discharge (t16.t6.a0))
(step t16.t7 (cl (=> (>= x (- 1)) false) false) :rule resolution :premises (t16.t5 t16.t6))
(step t16.t8 (cl (=> (>= x (- 1)) false) (not false)) :rule implies_neg2)
(step t16.t9 (cl (=> (>= x (- 1)) false) (=> (>= x (- 1)) false)) :rule resolution :premises (t16.t7 t16.t8))
(step t16.t10 (cl (=> (>= x (- 1)) false)) :rule contraction :premises (t16.t9))
(step t16.t11 (cl (= (=> (>= x (- 1)) false) (not (>= x (- 1))))) :rule implies_simplify)
(step t16.t12 (cl (not (=> (>= x (- 1)) false)) (not (>= x (- 1)))) :rule equiv1 :premises (t16.t11))
(step t16.t13 (cl (not (>= x (- 1)))) :rule resolution :premises (t16.t10 t16.t12))
(step t16.t14 (cl (< x (- 1))) :rule resolution :premises (t16.t3 t16.t4 t16.t13))
(step t16.t15 (cl (not (>= x (- 1)))) :rule resolution :premises (t16.t1 t16.t2 t16.t14))
(step t16.t16 (cl) :rule resolution :premises (t16.a2 t16.t15))
(step t16 (cl (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1))) false) :rule subproof :discharge (t16.a0 t16.a1 t16.a2))
(step t17 (cl (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule and_pos)
(step t18 (cl (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) :rule and_pos)
(step t19 (cl (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) (>= x (- 1))) :rule and_pos)
(step t20 (cl false (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))))) :rule resolution :premises (t16 t17 t18 t19))
(step t21 (cl (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) false) :rule reordering :premises (t20))
(step t22 (cl (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))) false) :rule contraction :premises (t21))
(step t23 (cl (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false) false) :rule resolution :premises (t15 t22))
(step t24 (cl (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false) (not false)) :rule implies_neg2)
(step t25 (cl (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false) (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false)) :rule resolution :premises (t23 t24))
(step t26 (cl (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false)) :rule contraction :premises (t25))
(step t27 (cl (= (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false) (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1)))))) :rule implies_simplify)
(step t28 (cl (not (=> (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))) false)) (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))))) :rule equiv1 :premises (t27))
(step t29 (cl (not (and (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= x (- 1))))) :rule resolution :premises (t26 t28))
(step t30 (cl (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) :rule not_and :premises (t29))
(step t31 (cl (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) (not (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))))) :rule or_neg)
(step t32 (cl (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) (not (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)))) :rule or_neg)
(step t33 (cl (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) (not (not (>= x (- 1))))) :rule or_neg)
(step t34 (cl (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1))))) :rule resolution :premises (t30 t31 t32 t33))
(step t35 (cl (or (not (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1))))) :rule contraction :premises (t34))
(step t36 (cl (or (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1))))) :rule resolution :premises (t1 t14 t35))
(step t37 (cl (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) (not (>= x (- 1)))) :rule or :premises (t36))
(step t38 (cl (not (>= x (- 1))) (>= (+ (* (- 1) y) x) (/ (- 2) 3)) (not (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0))) :rule reordering :premises (t37))
(step t39 (cl (not (= (not (<= (- y x) (/ 2 3))) (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) (not (not (<= (- y x) (/ 2 3)))) (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule equiv_pos2)
(step t40 (cl (= (- y x) (+ y (* (- 1) x)))) :rule all_simplify)
(step t41 (cl (= (/ 2 3) (/ 2 3))) :rule refl)
(step t42 (cl (= (<= (- y x) (/ 2 3)) (<= (+ y (* (- 1) x)) (/ 2 3)))) :rule cong :premises (t40 t41))
(step t43 (cl (= (<= (+ y (* (- 1) x)) (/ 2 3)) (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule all_simplify)
(step t44 (cl (= (<= (- y x) (/ 2 3)) (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule trans :premises (t42 t43))
(step t45 (cl (= (not (<= (- y x) (/ 2 3))) (not (>= (+ (* (- 1) y) x) (/ (- 2) 3))))) :rule cong :premises (t44))
(step t46 (cl (not (>= (+ (* (- 1) y) x) (/ (- 2) 3)))) :rule resolution :premises (t39 t45 a1))
(step t47 (cl (not (= (and (>= x (* 3 y)) (<= x y) (< (- 2) x)) (and (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= (+ y (* (- 1) x)) 0) (>= x (- 1))))) (not (and (>= x (* 3 y)) (<= x y) (< (- 2) x))) (and (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= (+ y (* (- 1) x)) 0) (>= x (- 1)))) :rule equiv_pos2)
(step t48 (cl (= (>= x (* 3 y)) (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0))) :rule all_simplify)
(step t49 (cl (= (<= x y) (>= (+ y (* (- 1) x)) 0))) :rule all_simplify)
(step t50 (cl (= (< (- 2) x) (not (>= (- 2) x)))) :rule all_simplify)
(step t51 (cl (= (>= (- 2) x) (not (>= x (- 1))))) :rule all_simplify)
(step t52 (cl (= (not (>= (- 2) x)) (not (not (>= x (- 1)))))) :rule cong :premises (t51))
(step t53 (cl (= (not (not (>= x (- 1)))) (>= x (- 1)))) :rule all_simplify)
(step t54 (cl (= (not (>= (- 2) x)) (>= x (- 1)))) :rule trans :premises (t52 t53))
(step t55 (cl (= (< (- 2) x) (>= x (- 1)))) :rule trans :premises (t50 t54))
(step t56 (cl (= (and (>= x (* 3 y)) (<= x y) (< (- 2) x)) (and (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= (+ y (* (- 1) x)) 0) (>= x (- 1))))) :rule cong :premises (t48 t49 t55))
(step t57 (cl (and (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0) (>= (+ y (* (- 1) x)) 0) (>= x (- 1)))) :rule resolution :premises (t47 t56 a0))
(step t58 (cl (>= x (- 1))) :rule and :premises (t57))
(step t59 (cl (>= (+ (* (- 1) y) (* (/ 1 3) x)) 0)) :rule and :premises (t57))
(step t60 (cl) :rule resolution :premises (t38 t46 t58 t59))

